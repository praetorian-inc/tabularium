// Command slimgen generates simplified Go types from the Tabularium model registry.
// These slim types are used by external tool writers and live in pkg/slim/.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	_ "github.com/praetorian-inc/tabularium/pkg/model/model"
	"github.com/praetorian-inc/tabularium/pkg/registry"
)

// modelConfig defines the generation order and allowed fields for each slim type.
// vulnerability is intentionally excluded: after filtering, it only retains Id,
// which is not worth generating a slim type for.
var modelConfig = []struct {
	Name   string
	Fields []string
}{
	{"port", []string{"Protocol", "Port", "Service", "Capability"}},
	{"risk", []string{"DNS", "Name", "Comment"}},
	{"technology", []string{"CPE", "Name", "Comment"}},
	{"attribute", []string{"Name", "Value", "Capability", "Metadata"}},
	{"file", []string{"Name", "Bytes"}},
	{"webpage", []string{"URL"}},
	{"webapplication", []string{"PrimaryURL", "URLs", "Name"}},
}

// slimField represents a field to include in a generated slim type.
type slimField struct {
	Name         string
	GoType       string
	JSONTag      string
	Desc         string // from the desc struct tag
	IsSmartBytes bool   // true if the original type was SmartBytes (mapped to []byte)
}

// parentKind describes how a model references its parent.
type parentKind int

const (
	parentNone     parentKind = iota
	parentInject              // GraphModelWrapper -- inject parent into child JSON
	parentNoInject            // *WebApplication -- convert parent but do not inject
)

// modelOutput holds the collected information for a single slim type.
type modelOutput struct {
	name          string
	pascalName    string
	fields        []slimField
	parent        parentKind
	hasByteFields bool // true if any field was mapped from SmartBytes to []byte
}

func main() {
	outputDir := flag.String("output", "pkg/slim/", "Output directory for generated slim types")
	flag.Parse()

	var buf bytes.Buffer
	buf.WriteString("// Code generated by slimgen. DO NOT EDIT.\n\n")
	buf.WriteString("package slim\n\n")

	// Collect all generated types first to determine imports
	var models []modelOutput

	for _, mc := range modelConfig {
		typ, ok := registry.Registry.GetType(mc.Name)
		if !ok {
			fmt.Fprintf(os.Stderr, "Warning: model %q not found in registry, skipping\n", mc.Name)
			continue
		}

		// Registry stores pointer types; dereference to get the struct.
		if typ.Kind() == reflect.Ptr {
			typ = typ.Elem()
		}

		if typ.Kind() != reflect.Struct {
			fmt.Fprintf(os.Stderr, "Warning: model %q is not a struct, skipping\n", mc.Name)
			continue
		}

		fields, pk, hasBytes := collectFields(mc.Name, mc.Fields, typ)
		models = append(models, modelOutput{
			name:          mc.Name,
			pascalName:    typ.Name(),
			fields:        fields,
			parent:        pk,
			hasByteFields: hasBytes,
		})
	}

	// Check if any model has byte fields that need encoding/json for MarshalJSON.
	needsJSON := false
	for _, m := range models {
		if m.hasByteFields {
			needsJSON = true
			break
		}
	}

	if needsJSON {
		buf.WriteString("import \"encoding/json\"\n\n")
	}

	// Generate each slim type
	for _, m := range models {
		typeName := "Slim" + m.pascalName

		fmt.Fprintf(&buf, "// %s is a simplified %s for external tool writers.\n", typeName, m.pascalName)
		fmt.Fprintf(&buf, "type %s struct {\n", typeName)

		if m.parent != parentNone {
			fmt.Fprintf(&buf, "\tAsset SlimAsset `json:\"-\"`\n")
		}

		for _, f := range m.fields {
			if f.Desc != "" {
				fmt.Fprintf(&buf, "\t// %s\n", f.Desc)
			}
			fmt.Fprintf(&buf, "\t%s %s `json:\"%s\"`\n", f.Name, f.GoType, f.JSONTag)
		}

		fmt.Fprintf(&buf, "}\n\n")
		fmt.Fprintf(&buf, "func (%s) TargetModel() string { return %q }\n\n", typeName, m.name)

		// Generate GetParentAsset for types with any parent reference.
		// The bool return indicates whether to inject the parent into child JSON.
		if m.parent != parentNone {
			fmt.Fprintf(&buf, "// GetParentAsset returns the embedded parent asset for %s.\n", typeName)
			fmt.Fprintf(&buf, "// The bool indicates whether to inject the parent into the child JSON.\n")
			fmt.Fprintf(&buf, "func (s %s) GetParentAsset() (SlimAsset, bool) { return s.Asset, %t }\n\n", typeName, m.parent == parentInject)
		}

		// Generate MarshalJSON for types with []byte fields (from SmartBytes)
		// so that the bytes are serialized as strings, not base64.
		if m.hasByteFields {
			fmt.Fprintf(&buf, "// MarshalJSON implements json.Marshaler so that []byte fields are\n")
			fmt.Fprintf(&buf, "// serialized as strings (matching SmartBytes behavior) instead of base64.\n")
			fmt.Fprintf(&buf, "func (s %s) MarshalJSON() ([]byte, error) {\n", typeName)
			fmt.Fprintf(&buf, "\ttype alias %s\n", typeName)
			fmt.Fprintf(&buf, "\traw := struct {\n")
			fmt.Fprintf(&buf, "\t\talias\n")
			for _, f := range m.fields {
				if f.IsSmartBytes {
					fmt.Fprintf(&buf, "\t\t%s string `json:\"%s\"`\n", f.Name, f.JSONTag)
				}
			}
			fmt.Fprintf(&buf, "\t}{\n")
			fmt.Fprintf(&buf, "\t\talias: alias(s),\n")
			for _, f := range m.fields {
				if f.IsSmartBytes {
					fmt.Fprintf(&buf, "\t\t%s: string(s.%s),\n", f.Name, f.Name)
				}
			}
			fmt.Fprintf(&buf, "\t}\n")
			fmt.Fprintf(&buf, "\treturn json.Marshal(raw)\n")
			fmt.Fprintf(&buf, "}\n\n")
		}
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\n", err)
		fmt.Fprintf(os.Stderr, "Unformatted output:\n%s\n", buf.String())
		os.Exit(1)
	}

	// Write to output file
	outputPath := filepath.Join(*outputDir, "gen_models.go")
	if err := os.MkdirAll(*outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated slim types at %s\n", outputPath)
}

// collectFields inspects a struct type and returns the fields to include in
// the slim type along with the parentKind indicating how the model references
// its parent (if at all). Only fields listed in allowList are included.
func collectFields(modelName string, allowList []string, typ reflect.Type) ([]slimField, parentKind, bool) {
	var fields []slimField
	pk := parentNone
	hasBytes := false

	// Build a set of allowed field names for this model.
	allowed := make(map[string]bool)
	for _, name := range allowList {
		allowed[name] = true
	}

	// Build a set of visible field names for validation.
	visibleNames := make(map[string]bool)

	// Use VisibleFields to handle promoted fields from embedded structs.
	for _, sf := range reflect.VisibleFields(typ) {
		if !sf.IsExported() {
			continue
		}

		// Skip anonymous (embedded) fields themselves -- we process their
		// promoted children via VisibleFields.
		if sf.Anonymous {
			continue
		}

		visibleNames[sf.Name] = true

		// Detect GraphModelWrapper fields (direct parent reference).
		fieldType := sf.Type
		if fieldType.Name() == "GraphModelWrapper" || (fieldType.Kind() == reflect.Ptr && fieldType.Elem().Name() == "GraphModelWrapper") {
			pk = parentInject
			continue
		}

		// Detect pointer to WebApplication (Webpage.Parent). A *WebApplication
		// pointer indicates a parent relationship, but unlike GraphModelWrapper,
		// the parent should NOT be injected into the child JSON.
		if fieldType.Kind() == reflect.Ptr && fieldType.Elem().Name() == "WebApplication" {
			pk = parentNoInject
			continue
		}

		// Only include fields that are in the allow-list.
		if !allowed[sf.Name] {
			continue
		}

		// Check the json tag -- skip json:"-" fields.
		jsonTag := sf.Tag.Get("json")
		if jsonTag == "-" || strings.HasPrefix(jsonTag, "-,") {
			continue
		}

		// Build the field entry.
		jsonName, omitempty := parseJSONTag(jsonTag, sf.Name)
		goType := goTypeName(fieldType)
		isSmartBytes := goType == "SmartBytes"
		if isSmartBytes {
			goType = "[]byte"
			hasBytes = true
		}
		desc := sf.Tag.Get("desc")

		tag := jsonName
		if omitempty {
			tag += ",omitempty"
		}

		fields = append(fields, slimField{
			Name:         sf.Name,
			GoType:       goType,
			JSONTag:      tag,
			Desc:         desc,
			IsSmartBytes: isSmartBytes,
		})
	}

	// Validate that all allowed field names exist in the model struct.
	for _, name := range allowList {
		if !visibleNames[name] {
			fmt.Fprintf(os.Stderr, "Warning: allowed field %q does not exist in model %q\n", name, modelName)
		}
	}

	return fields, pk, hasBytes
}

// parseJSONTag extracts the JSON field name and omitempty flag from a json tag.
func parseJSONTag(tag, fieldName string) (string, bool) {
	if tag == "" {
		return fieldName, false
	}
	parts := strings.Split(tag, ",")
	name := parts[0]
	if name == "" {
		name = fieldName
	}
	omitempty := false
	for _, p := range parts[1:] {
		if p == "omitempty" {
			omitempty = true
		}
	}
	return name, omitempty
}

// goTypeName returns the Go source representation of a type.
func goTypeName(t reflect.Type) string {
	// Handle named types first -- types like SmartBytes are named slices
	// that need to preserve their name.
	if t.Name() != "" && t.PkgPath() != "" {
		// This is a named type from a package (e.g., model.SmartBytes).
		// Return just the short name; the caller handles package qualification.
		return t.Name()
	}

	switch t.Kind() {
	case reflect.Ptr:
		return "*" + goTypeName(t.Elem())
	case reflect.Slice:
		return "[]" + goTypeName(t.Elem())
	case reflect.Map:
		return "map[" + goTypeName(t.Key()) + "]" + goTypeName(t.Elem())
	case reflect.Interface:
		return "any"
	default:
		return t.Name()
	}
}
