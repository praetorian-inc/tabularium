// Command slimgen generates simplified Go types from the Tabularium model registry.
// These slim types are used by external tool writers and live in pkg/slim/.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	_ "github.com/praetorian-inc/tabularium/pkg/model/model"
	"github.com/praetorian-inc/tabularium/pkg/registry"
)

// tier1Models lists the registry names of models to generate slim types for.
// vulnerability is intentionally excluded: after filtering, it only retains Id,
// which is not worth generating a slim type for. Tool writers reference
// vulnerabilities by ID directly in Risk.Name.
var tier1Models = []string{
	"port",
	"risk",
	"technology",
	"attribute",
	"file",
	"webpage",
	"webapplication",
}

// ignoreFields lists field names to always exclude from slim types.
var ignoreFields = map[string]bool{
	"Key":             true,
	"Username":        true,
	"Status":          true,
	"Source":          true,
	"Origin":          true,
	"Created":         true,
	"Visited":         true,
	"Updated":         true,
	"TTL":             true,
	"Secret":          true,
	"Group":           true,
	"Identifier":      true,
	"Class":           true,
	"Priority":        true,
	"State":           true,
	"PlextracID":      true, // PlexTrac integration, internal
	"OriginSource":    true, // provenance tracking, internal
	"Data":            true, // enrichment blob, internal
	"Feed":            true, // threat feed source, internal
	"WriteupId":       true, // PlexTrac, internal
	"KevDateAdded":    true, // enrichment, internal
	"KevDueDate":      true, // enrichment, internal
	"Exploit":         true, // enrichment flag, internal
	"Kev":             true, // enrichment flag, internal
	"CVSS":            true, // enrichment score, internal
	"EPSS":            true, // enrichment score, internal
	"Title":           true, // enrichment data, internal
	"DetailsFilepath": true, // internal storage path
	"Screenshot":      true, // internal storage path
	"Resources":       true, // internal storage path
	"Private":         true, // computed by hooks, not set by tool writers
}

// perModelIgnoreFields lists field names to exclude for specific models only.
var perModelIgnoreFields = map[string]map[string]bool{
	"webpage": {"Metadata": true},
}

// ignoreEmbeddedTypes lists embedded type names to always ignore.
// Fields from these embedded types are excluded from slim types.
var ignoreEmbeddedTypes = map[string]bool{
	"BaseModel":                 true,
	"BaseAsset":                 true,
	"History":                   true,
	"MLProperties":              true,
	"Tags":                      true,
	"OriginationData":           true,
	"Metadata":                  true,
	"LabelSettableEmbed":        true,
	"BurpMetadata":              true,
	"ModelAlias":                true,
	"baseTableModel":            true,
	"ThreatNotificationMetadata": true,
	"EndpointFingerprint":       true,
	"WebpageDetails":            true,
	"WebApplicationDetails":     true,
	"CPE":                       true,
}

// slimField represents a field to include in a generated slim type.
type slimField struct {
	Name    string
	GoType  string
	JSONTag string
	Desc    string // from the desc struct tag
}

func main() {
	outputDir := flag.String("output", "pkg/slim/", "Output directory for generated slim types")
	flag.Parse()

	var buf bytes.Buffer
	buf.WriteString("// Code generated by slimgen. DO NOT EDIT.\n\n")
	buf.WriteString("package slim\n\n")

	// Collect all generated types first to determine imports
	type modelOutput struct {
		name                string
		pascalName          string
		fields              []slimField
		hasDirectParentRef  bool // true when the model has a GraphModelWrapper parent
		hasIndirectParentRef bool // true when the model has a *WebApplication parent
	}

	var models []modelOutput

	for _, modelName := range tier1Models {
		typ, ok := registry.Registry.GetType(modelName)
		if !ok {
			fmt.Fprintf(os.Stderr, "Warning: model %q not found in registry, skipping\n", modelName)
			continue
		}

		// Registry stores pointer types; dereference to get the struct.
		if typ.Kind() == reflect.Ptr {
			typ = typ.Elem()
		}

		if typ.Kind() != reflect.Struct {
			fmt.Fprintf(os.Stderr, "Warning: model %q is not a struct, skipping\n", modelName)
			continue
		}

		fields, directParent, indirectParent := collectFields(modelName, typ)
		models = append(models, modelOutput{
			name:                 modelName,
			pascalName:           typ.Name(),
			fields:               fields,
			hasDirectParentRef:   directParent,
			hasIndirectParentRef: indirectParent,
		})
	}

	// Always emit the model package import; generated code uses model.SmartBytes.
	buf.WriteString("import \"github.com/praetorian-inc/tabularium/pkg/model/model\"\n\n")

	// Generate each slim type
	for _, m := range models {
		typeName := "Slim" + m.pascalName
		originalName := m.pascalName
		hasParent := m.hasDirectParentRef || m.hasIndirectParentRef

		fmt.Fprintf(&buf, "// %s is a simplified %s for external tool writers.\n", typeName, originalName)
		fmt.Fprintf(&buf, "type %s struct {\n", typeName)

		if hasParent {
			fmt.Fprintf(&buf, "\tAsset SlimAsset `json:\"-\"`\n")
		}

		for _, f := range m.fields {
			goType := f.GoType
			// Replace model-package types with fully qualified names
			if goType == "SmartBytes" {
				goType = "model.SmartBytes"
			}
			if f.Desc != "" {
				fmt.Fprintf(&buf, "\t// %s\n", f.Desc)
			}
			fmt.Fprintf(&buf, "\t%s %s `json:\"%s\"`\n", f.Name, goType, f.JSONTag)
		}

		fmt.Fprintf(&buf, "}\n\n")
		fmt.Fprintf(&buf, "func (%s) TargetModel() string { return %q }\n\n", typeName, m.name)

		// Generate GetParentAsset for types with any parent reference.
		if hasParent {
			fmt.Fprintf(&buf, "// GetParentAsset returns the embedded parent asset for %s.\n", typeName)
			fmt.Fprintf(&buf, "func (s %s) GetParentAsset() SlimAsset { return s.Asset }\n\n", typeName)
		}

		// Generate injectParent marker only for direct GraphModelWrapper parents.
		if m.hasDirectParentRef {
			fmt.Fprintf(&buf, "func (%s) injectParent() {}\n\n", typeName)
		}
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\n", err)
		fmt.Fprintf(os.Stderr, "Unformatted output:\n%s\n", buf.String())
		os.Exit(1)
	}

	// Write to output file
	outputPath := filepath.Join(*outputDir, "gen_models.go")
	if err := os.MkdirAll(*outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated slim types at %s\n", outputPath)
}

// collectFields inspects a struct type and returns the fields to include in
// the slim type. It returns the field list and two booleans:
//   - hasDirectParentRef: true if the model has a GraphModelWrapper parent field
//   - hasIndirectParentRef: true if the model has a *WebApplication parent field
//
// Both indicate that the slim type should embed a SlimAsset.
func collectFields(modelName string, typ reflect.Type) ([]slimField, bool, bool) {
	var fields []slimField
	hasDirectParentRef := false
	hasIndirectParentRef := false

	modelIgnore := perModelIgnoreFields[modelName]

	// Use VisibleFields to handle promoted fields from embedded structs.
	for _, sf := range reflect.VisibleFields(typ) {
		if !sf.IsExported() {
			continue
		}

		// Skip anonymous (embedded) fields themselves -- we process their
		// promoted children via VisibleFields.
		if sf.Anonymous {
			continue
		}

		// If this field is promoted from an embedded struct (index path > 1),
		// check whether the embedding type is in the ignore list.
		if len(sf.Index) > 1 && isFromIgnoredEmbed(typ, sf) {
			continue
		}

		// Check the json tag -- skip json:"-" fields.
		jsonTag := sf.Tag.Get("json")
		if jsonTag == "-" || strings.HasPrefix(jsonTag, "-,") {
			continue
		}

		// Check the static ignore list.
		if ignoreFields[sf.Name] {
			continue
		}

		// Check the per-model ignore list.
		if modelIgnore[sf.Name] {
			continue
		}

		// Detect GraphModelWrapper fields (direct parent reference).
		fieldType := sf.Type
		if fieldType.Name() == "GraphModelWrapper" || (fieldType.Kind() == reflect.Ptr && fieldType.Elem().Name() == "GraphModelWrapper") {
			hasDirectParentRef = true
			continue
		}

		// Detect pointer to WebApplication (Webpage.Parent). A *WebApplication
		// pointer indicates a parent relationship, but unlike GraphModelWrapper,
		// the parent should NOT be injected into the child JSON.
		if fieldType.Kind() == reflect.Ptr && fieldType.Elem().Name() == "WebApplication" {
			hasIndirectParentRef = true
			continue
		}

		// Skip fields with complex model-package types that don't exist in
		// the slim package. Only allow primitive types, strings, basic
		// slices/maps, and pointer-to-primitive types.
		if !isSlimCompatibleType(fieldType) {
			continue
		}

		// Build the field entry.
		jsonName, omitempty := parseJSONTag(jsonTag, sf.Name)
		goType := goTypeName(fieldType)
		desc := sf.Tag.Get("desc")

		tag := jsonName
		if omitempty {
			tag += ",omitempty"
		}

		fields = append(fields, slimField{
			Name:    sf.Name,
			GoType:  goType,
			JSONTag: tag,
			Desc:    desc,
		})
	}

	return fields, hasDirectParentRef, hasIndirectParentRef
}

// isFromIgnoredEmbed checks whether a promoted field originates from an
// embedded struct that is in the ignoreEmbeddedTypes set.
func isFromIgnoredEmbed(typ reflect.Type, sf reflect.StructField) bool {
	// Walk up the index path to find each embedding layer.
	current := typ
	for i := 0; i < len(sf.Index)-1; i++ {
		embedField := current.Field(sf.Index[i])
		embedType := embedField.Type
		if embedType.Kind() == reflect.Ptr {
			embedType = embedType.Elem()
		}
		if ignoreEmbeddedTypes[embedType.Name()] {
			return true
		}
		current = embedType
	}
	return false
}

// parseJSONTag extracts the JSON field name and omitempty flag from a json tag.
func parseJSONTag(tag, fieldName string) (string, bool) {
	if tag == "" {
		return strings.ToLower(fieldName), false
	}
	parts := strings.Split(tag, ",")
	name := parts[0]
	if name == "" {
		name = fieldName
	}
	omitempty := false
	for _, p := range parts[1:] {
		if p == "omitempty" {
			omitempty = true
		}
	}
	return name, omitempty
}

// goTypeName returns the Go source representation of a type.
func goTypeName(t reflect.Type) string {
	// Handle named types first -- types like SmartBytes are named slices
	// that need to preserve their name.
	if t.Name() != "" && t.PkgPath() != "" {
		// This is a named type from a package (e.g., model.SmartBytes).
		// Return just the short name; the caller handles package qualification.
		return t.Name()
	}

	switch t.Kind() {
	case reflect.Ptr:
		return "*" + goTypeName(t.Elem())
	case reflect.Slice:
		return "[]" + goTypeName(t.Elem())
	case reflect.Map:
		return "map[" + goTypeName(t.Key()) + "]" + goTypeName(t.Elem())
	case reflect.Interface:
		return "any"
	default:
		return t.Name()
	}
}

// isSlimCompatibleType returns true if the type can be represented directly
// in the slim package without importing model-specific struct types.
// Allowed: primitives, strings, []byte, []string, map[string]string,
// map[string]any, pointers to primitives, and the SmartBytes named type.
func isSlimCompatibleType(t reflect.Type) bool {
	switch t.Kind() {
	case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32,
		reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32,
		reflect.Uint64, reflect.Float32, reflect.Float64, reflect.String:
		return true
	case reflect.Ptr:
		return isSlimCompatibleType(t.Elem())
	case reflect.Slice:
		elem := t.Elem()
		// Allow []byte (and named aliases like SmartBytes), []string
		if elem.Kind() == reflect.Uint8 || elem.Kind() == reflect.String {
			return true
		}
		return false
	case reflect.Map:
		// Allow map[string]string and map[string]any
		if t.Key().Kind() == reflect.String {
			valKind := t.Elem().Kind()
			if valKind == reflect.String || (valKind == reflect.Interface && t.Elem().NumMethod() == 0) {
				return true
			}
		}
		return false
	default:
		return false
	}
}
