// Command capmodelgen generates capability model Go types from the Tabularium model registry.
// These capability model types are used by external tool writers and live in pkg/capmodel/.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	_ "github.com/praetorian-inc/tabularium/pkg/model/model"
	"github.com/praetorian-inc/tabularium/pkg/registry"
)

// typeMap maps named type aliases to their underlying Go type representation.
// This allows the generator to use built-in types instead of model-specific aliases.
var typeMap = map[string]string{
	"SmartBytes":        "[]byte",
	"CloudResourceType": "string",
	"GobSafeBool":       "bool",
}

// modelConfig defines the generation order and allowed fields for each capability model type.
// vulnerability is intentionally excluded: after filtering, it only retains Id,
// which is not worth generating a capability model type for.
//
// RegistryModel is an optional field that, when set, causes the generator to
// look up that name in the registry instead of Name. This enables N:1 mappings
// where multiple capability model types target the same underlying model.
// All existing entries leave it empty (backward compatible).
var modelConfig = []struct {
	Name          string
	RegistryModel string // if set, look up this model in the registry instead of Name
	Fields        []string
}{
	{Name: "port", Fields: []string{"Protocol", "Port", "Service", "Capability"}},
	{Name: "risk", Fields: []string{"DNS", "Name", "Comment"}},
	{Name: "technology", Fields: []string{"CPE", "Name", "Comment"}},
	{Name: "attribute", Fields: []string{"Name", "Value", "Capability", "Metadata"}},
	{Name: "file", Fields: []string{"Name", "Bytes"}},
	{Name: "webpage", Fields: []string{"URL"}},
	{Name: "webapplication", Fields: []string{"PrimaryURL", "URLs", "Name"}},
	// Preseed
	{Name: "preseed", Fields: []string{"Type", "Title", "Value", "Display", "Capability", "Metadata", "Comment"}},
	// Cloud resource types
	{Name: "cloudresource", Fields: []string{"Name", "DisplayName", "Provider", "ResourceType", "Region", "AccountRef", "IPs", "URLs", "Properties", "Labels"}},
	{Name: "awsresource", Fields: []string{"Name", "DisplayName", "Provider", "ResourceType", "Region", "AccountRef", "IPs", "URLs", "Properties", "Labels", "OrgPolicyFilename"}},
	{Name: "azureresource", Fields: []string{"Name", "DisplayName", "Provider", "ResourceType", "Region", "AccountRef", "IPs", "URLs", "Properties", "Labels", "ResourceGroup"}},
	{Name: "gcpresource", Fields: []string{"Name", "DisplayName", "Provider", "ResourceType", "Region", "AccountRef", "IPs", "URLs", "Properties", "Labels"}},
	// Active Directory
	{Name: "adobject", Fields: []string{"Label", "SecondaryLabels", "Domain", "ObjectID", "SID", "Name", "DisplayName", "Description", "DistinguishedName", "SAMAccountName", "DNSHostname", "OperatingSystem", "Department", "AdminCount", "HasSPN", "UnconstrainedDelegation", "TrustedToAuth", "DontRequirePreAuth", "PasswordNeverExpires", "HasLAPS", "IsDC", "Sensitive", "ServicePrincipalNames", "DomainSID", "FunctionalLevel", "LastLogon"}},
	// People and organizations
	{Name: "person", Fields: []string{"FirstName", "LastName", "Name", "Email", "Title", "Headline", "Phone", "WorkEmail", "PersonalEmails", "LinkedinURL", "GithubURL", "OrganizationName", "Country", "State", "City", "Seniority", "Departments", "EmailStatus"}},
	{Name: "organization", Fields: []string{"Name", "Domain", "Website", "Description", "Industry", "SubIndustries", "EstimatedNumEmployees", "EmployeeRange", "AnnualRevenue", "RevenueRange", "Country", "State", "City", "Phone", "Email", "LinkedinURL", "FoundedYear", "Technologies", "Keywords", "PubliclyTraded"}},
}

// capmodelField represents a field to include in a generated capability model type.
type capmodelField struct {
	Name         string
	GoType       string
	JSONTag      string
	Desc         string // from the desc struct tag
	IsSmartBytes bool   // true if the original type was SmartBytes (mapped to []byte)
}

// parentKind describes how a model references its parent.
type parentKind int

const (
	parentNone     parentKind = iota
	parentInject              // GraphModelWrapper -- inject parent into child JSON
	parentNoInject            // *WebApplication -- convert parent but do not inject
)

// templateData holds all the information the template needs to generate a single model file.
type templateData struct {
	TypeName         string // Go type name (from the registry struct)
	RegistryName     string // registry key used for TargetModel()
	ConfigName       string // config entry name (used for output filename)
	Fields           []capmodelField
	HasParent        bool
	InjectParent     bool
	HasByteFields    bool
	NeedsJSON        bool
	SmartBytesFields []capmodelField
}

// modelTemplate is the Go text/template used to generate a single capability model file.
const modelTemplate = `// Code generated by capmodelgen. DO NOT EDIT.

package capmodel
{{if .NeedsJSON}}
import "encoding/json"
{{end}}
// {{.TypeName}} is a capability model for {{.TypeName}}.
type {{.TypeName}} struct {
{{- if .HasParent}}
	Asset Asset ` + "`" + `json:"-"` + "`" + `
{{- end}}
{{- range .Fields}}
{{- if .Desc}}
	// {{.Desc}}
{{- end}}
	{{.Name}} {{.GoType}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}

func ({{.TypeName}}) TargetModel() string { return "{{.RegistryName}}" }
{{if .HasParent}}
// GetParentAsset returns the embedded parent asset for {{.TypeName}}.
// The bool indicates whether to inject the parent into the child JSON.
func (s {{.TypeName}}) GetParentAsset() (Asset, bool) { return s.Asset, {{.InjectParent}} }
{{end}}
{{- if .HasByteFields}}
// MarshalJSON implements json.Marshaler so that []byte fields are
// serialized as strings (matching SmartBytes behavior) instead of base64.
func (s {{.TypeName}}) MarshalJSON() ([]byte, error) {
	type alias {{.TypeName}}
	raw := struct {
		alias
{{- range .SmartBytesFields}}
		{{.Name}} string ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
	}{
		alias: alias(s),
{{- range .SmartBytesFields}}
		{{.Name}}: string(s.{{.Name}}),
{{- end}}
	}
	return json.Marshal(raw)
}
{{end}}
`

var tmpl = template.Must(template.New("model").Parse(modelTemplate))

func main() {
	outputDir := flag.String("output", "pkg/capmodel/", "Output directory for generated capability model types")
	flag.Parse()

	// Collect all generated types first.
	var models []templateData

	for _, mc := range modelConfig {
		// RegistryModel allows N:1 mapping: multiple config entries can
		// target the same underlying model with different field selections.
		registryLookup := mc.Name
		if mc.RegistryModel != "" {
			registryLookup = mc.RegistryModel
		}

		typ, ok := registry.Registry.GetType(registryLookup)
		if !ok {
			fmt.Fprintf(os.Stderr, "Warning: model %q not found in registry, skipping\n", registryLookup)
			continue
		}

		// Registry stores pointer types; dereference to get the struct.
		if typ.Kind() == reflect.Ptr {
			typ = typ.Elem()
		}

		if typ.Kind() != reflect.Struct {
			fmt.Fprintf(os.Stderr, "Warning: model %q is not a struct, skipping\n", mc.Name)
			continue
		}

		fields, pk, hasBytes := collectFields(registryLookup, mc.Fields, typ)

		// Collect SmartBytes fields for MarshalJSON generation.
		var smartBytesFields []capmodelField
		for _, f := range fields {
			if f.IsSmartBytes {
				smartBytesFields = append(smartBytesFields, f)
			}
		}

		models = append(models, templateData{
			TypeName:         typ.Name(),
			RegistryName:     registryLookup,
			ConfigName:       mc.Name,
			Fields:           fields,
			HasParent:        pk != parentNone,
			InjectParent:     pk == parentInject,
			HasByteFields:    hasBytes,
			NeedsJSON:        hasBytes,
			SmartBytesFields: smartBytesFields,
		})
	}

	// Ensure output directory exists.
	if err := os.MkdirAll(*outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Remove existing gen_*.go files to handle removed models and the old gen_models.go.
	matches, err := filepath.Glob(filepath.Join(*outputDir, "gen_*.go"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error globbing old generated files: %v\n", err)
		os.Exit(1)
	}
	for _, f := range matches {
		if err := os.Remove(f); err != nil {
			fmt.Fprintf(os.Stderr, "Error removing old generated file %s: %v\n", f, err)
			os.Exit(1)
		}
	}

	// Generate each model into its own file.
	for _, m := range models {
		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, m); err != nil {
			fmt.Fprintf(os.Stderr, "Error executing template for %s: %v\n", m.TypeName, err)
			os.Exit(1)
		}

		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error formatting generated code for %s: %v\n", m.TypeName, err)
			fmt.Fprintf(os.Stderr, "Unformatted output:\n%s\n", buf.String())
			os.Exit(1)
		}

		outputPath := filepath.Join(*outputDir, "gen_"+m.ConfigName+".go")
		if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", outputPath, err)
			os.Exit(1)
		}

		fmt.Printf("Generated %s\n", outputPath)
	}

	fmt.Printf("Generated %d capability model files in %s\n", len(models), *outputDir)
}

// collectFields inspects a struct type and returns the fields to include in
// the capability model type along with the parentKind indicating how the model references
// its parent (if at all). Only fields listed in allowList are included.
func collectFields(modelName string, allowList []string, typ reflect.Type) ([]capmodelField, parentKind, bool) {
	var fields []capmodelField
	pk := parentNone
	hasBytes := false

	// Build a set of allowed field names for this model.
	allowed := make(map[string]bool)
	for _, name := range allowList {
		allowed[name] = true
	}

	// Build a set of visible field names for validation.
	visibleNames := make(map[string]bool)

	// Use VisibleFields to handle promoted fields from embedded structs.
	for _, sf := range reflect.VisibleFields(typ) {
		if !sf.IsExported() {
			continue
		}

		// Skip anonymous (embedded) fields themselves -- we process their
		// promoted children via VisibleFields.
		if sf.Anonymous {
			continue
		}

		visibleNames[sf.Name] = true

		// Detect GraphModelWrapper fields (direct parent reference).
		fieldType := sf.Type
		if fieldType.Name() == "GraphModelWrapper" || (fieldType.Kind() == reflect.Ptr && fieldType.Elem().Name() == "GraphModelWrapper") {
			pk = parentInject
			continue
		}

		// Detect pointer to WebApplication (Webpage.Parent). A *WebApplication
		// pointer indicates a parent relationship, but unlike GraphModelWrapper,
		// the parent should NOT be injected into the child JSON.
		if fieldType.Kind() == reflect.Ptr && fieldType.Elem().Name() == "WebApplication" {
			pk = parentNoInject
			continue
		}

		// Only include fields that are in the allow-list.
		if !allowed[sf.Name] {
			continue
		}

		// Check the json tag -- skip json:"-" fields.
		jsonTag := sf.Tag.Get("json")
		if jsonTag == "-" || strings.HasPrefix(jsonTag, "-,") {
			continue
		}

		// Build the field entry.
		jsonName, omitempty := parseJSONTag(jsonTag, sf.Name)
		isSmartBytes := fieldType.Name() == "SmartBytes"
		goType := goTypeName(fieldType)
		if isSmartBytes {
			hasBytes = true
		}
		desc := sf.Tag.Get("desc")

		tag := jsonName
		if omitempty {
			tag += ",omitempty"
		}

		fields = append(fields, capmodelField{
			Name:         sf.Name,
			GoType:       goType,
			JSONTag:      tag,
			Desc:         desc,
			IsSmartBytes: isSmartBytes,
		})
	}

	// Validate that all allowed field names exist in the model struct.
	for _, name := range allowList {
		if !visibleNames[name] {
			fmt.Fprintf(os.Stderr, "Warning: allowed field %q does not exist in model %q\n", name, modelName)
		}
	}

	return fields, pk, hasBytes
}

// parseJSONTag extracts the JSON field name and omitempty flag from a json tag.
func parseJSONTag(tag, fieldName string) (string, bool) {
	if tag == "" {
		return fieldName, false
	}
	parts := strings.Split(tag, ",")
	name := parts[0]
	if name == "" {
		name = fieldName
	}
	omitempty := false
	for _, p := range parts[1:] {
		if p == "omitempty" {
			omitempty = true
		}
	}
	return name, omitempty
}

// goTypeName returns the Go source representation of a type.
func goTypeName(t reflect.Type) string {
	// Handle named types first -- types like SmartBytes are named slices
	// that need to preserve their name.
	if t.Name() != "" && t.PkgPath() != "" {
		if mapped, ok := typeMap[t.Name()]; ok {
			return mapped
		}
		// This is a named type from a package (e.g., model.SmartBytes).
		// Return just the short name; the caller handles package qualification.
		return t.Name()
	}

	switch t.Kind() {
	case reflect.Ptr:
		return "*" + goTypeName(t.Elem())
	case reflect.Slice:
		return "[]" + goTypeName(t.Elem())
	case reflect.Map:
		return "map[" + goTypeName(t.Key()) + "]" + goTypeName(t.Elem())
	case reflect.Interface:
		return "any"
	default:
		if t.Name() == "uint8" {
			return "byte"
		}
		return t.Name()
	}
}
