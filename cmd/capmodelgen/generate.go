package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"text/template"
)

const generatedHeader = `// Code generated by capmodelgen; DO NOT EDIT.

package capmodel

import (
	"encoding/json"

	"github.com/praetorian-inc/tabularium/pkg/model/model"
	"github.com/praetorian-inc/tabularium/pkg/registry"
)
`

type templateData struct {
	TypeName        string
	SourceTypeName  string
	Fields          []templateField
	ParentField     *templateParentField
}

type templateField struct {
	Name            string   // Go field name in slim type
	GoType          string
	JSONName        string   // json tag for the slim struct
	SourceJSONNames []string // json names in the source model (for Convert map)
}

type templateParentField struct {
	Name        string // Go field name (used in both slim struct and result assignment)
	SlimType    string // e.g., "Asset", "WebApplication"
	JSONName    string
	IsInject    bool // GraphModelWrapper — needs wrapping with NewGraphModelWrapper
	IsInterface bool // interface field (e.g., Target) — set after hooks
}

func generate(slimTypes []slimType, outputDir string) error {
	sort.Slice(slimTypes, func(i, j int) bool {
		return slimTypes[i].Name < slimTypes[j].Name
	})

	var buf bytes.Buffer
	buf.WriteString(generatedHeader)

	for _, st := range slimTypes {
		td := buildTemplateData(st)
		if err := typeTmpl.Execute(&buf, td); err != nil {
			return fmt.Errorf("generating %s: %w", st.Name, err)
		}
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		debugPath := filepath.Join(outputDir, "generated_debug.go")
		os.WriteFile(debugPath, buf.Bytes(), 0644)
		return fmt.Errorf("formatting generated code: %w (debug written to %s)", err, debugPath)
	}

	outPath := filepath.Join(outputDir, "generated.go")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	return os.WriteFile(outPath, formatted, 0644)
}

func buildTemplateData(st slimType) templateData {
	td := templateData{
		TypeName:       st.Name,
		SourceTypeName: st.SourceTypeName,
	}

	for _, f := range st.Fields {
		if f.EmbedSlimType != "" {
			td.ParentField = &templateParentField{
				Name:        f.SourceFieldName,
				SlimType:    f.EmbedSlimType,
				JSONName:    f.JSONName,
				IsInject:    f.GoType == "GraphModelWrapper",
				IsInterface: f.GoType == "any",
			}
			continue
		}

		td.Fields = append(td.Fields, templateField{
			Name:            f.SourceFieldName,
			GoType:          f.GoType,
			JSONName:        f.JSONName,
			SourceJSONNames: f.SourceJSONNames,
		})
	}

	return td
}

// needsParentBeforeHooks returns true if the parent must be set before hooks run.
// This is the case for all parent types except interfaces (which are set after).
func needsParentBeforeHooks(pf *templateParentField) bool {
	return pf != nil && !pf.IsInterface
}

var typeTmpl = template.Must(template.New("type").Funcs(template.FuncMap{
	"needsParentBeforeHooks": needsParentBeforeHooks,
}).Parse(`
// {{.TypeName}} is a capability model for model.{{.SourceTypeName}}.
type {{.TypeName}} struct {
{{- range .Fields}}
	{{.Name}} {{.GoType}} ` + "`" + `json:"{{.JSONName}}"` + "`" + `
{{- end}}
{{- if .ParentField}}
	{{.ParentField.Name}} {{.ParentField.SlimType}} ` + "`" + `json:"{{.ParentField.JSONName}}"` + "`" + `
{{- end}}
}

// Convert converts this capability model to a full model.{{.SourceTypeName}}.
func (s {{.TypeName}}) Convert() (*model.{{.SourceTypeName}}, error) {
	m := make(map[string]any)
{{- range $field := .Fields}}
{{- range $field.SourceJSONNames}}
	m["{{.}}"] = s.{{$field.Name}}
{{- end}}
{{- end}}
{{- if .ParentField}}
	parentModel, err := s.{{.ParentField.Name}}.Convert()
	if err != nil {
		return nil, err
	}
{{- end}}

	b, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}

{{- if needsParentBeforeHooks .ParentField}}
	// Parent must be set before hooks run (hooks depend on it).
	var result model.{{.SourceTypeName}}
	result.Defaulted()
	if err := json.Unmarshal(b, &result); err != nil {
		return nil, err
	}
{{- if .ParentField.IsInject}}
	result.{{.ParentField.Name}} = model.NewGraphModelWrapper(parentModel)
{{- else}}
	result.{{.ParentField.Name}} = parentModel
{{- end}}
	if err := registry.CallHooks(&result); err != nil {
		return nil, err
	}
{{- else}}
	var result model.{{.SourceTypeName}}
	if err := registry.UnmarshalModel(b, &result); err != nil {
		return nil, err
	}
{{- if .ParentField}}
{{- if .ParentField.IsInterface}}
	result.{{.ParentField.Name}} = parentModel
{{- end}}
{{- end}}
{{- end}}

	return &result, nil
}
`))
