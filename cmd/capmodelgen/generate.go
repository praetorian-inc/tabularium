package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const generatedHeader = `// Code generated by capmodelgen; DO NOT EDIT.

package capmodel

import (
	"encoding/json"

	"github.com/praetorian-inc/tabularium/pkg/model/model"
	"github.com/praetorian-inc/tabularium/pkg/registry"
)
`

// templateData holds all data for a single slim type template.
type templateData struct {
	TypeName        string
	SourceTypeName  string
	SourceModelName string
	Fields          []templateField
	ParentField     *templateParentField
}

type templateField struct {
	Name            string   // Go field name in slim type
	GoType          string
	JSONName        string   // json tag for the slim struct
	SourceJSONNames []string // json tag(s) in the source model (for Convert map)
}

type templateParentField struct {
	Name        string // Go field name (e.g., Target, Parent)
	SlimType    string // e.g., "Asset", "WebApplication"
	JSONName    string
	IsInject    bool // GraphModelWrapper â€” needs JSON injection
	IsInterface bool // interface field like Target
	IsPointer   bool // *WebApplication
	SourceField string
}

func generate(slimTypes []slimType, outputDir string) error {
	sort.Slice(slimTypes, func(i, j int) bool {
		return slimTypes[i].Name < slimTypes[j].Name
	})

	var buf bytes.Buffer
	buf.WriteString(generatedHeader)

	for _, st := range slimTypes {
		td := buildTemplateData(st)
		if err := writeType(&buf, td); err != nil {
			return fmt.Errorf("generating %s: %w", st.Name, err)
		}
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		debugPath := filepath.Join(outputDir, "generated_debug.go")
		os.WriteFile(debugPath, buf.Bytes(), 0644)
		return fmt.Errorf("formatting generated code: %w (debug written to %s)", err, debugPath)
	}

	outPath := filepath.Join(outputDir, "generated.go")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	return os.WriteFile(outPath, formatted, 0644)
}

func buildTemplateData(st slimType) templateData {
	td := templateData{
		TypeName:        st.Name,
		SourceTypeName:  st.SourceTypeName,
		SourceModelName: st.SourceModelName,
	}

	pi := getParentInfo(st)

	for _, f := range st.Fields {
		if f.EmbedSlimType != "" {
			if pi != nil {
				td.ParentField = &templateParentField{
					Name:        f.SourceFieldName,
					SlimType:    f.EmbedSlimType,
					JSONName:    f.JSONName,
					IsInject:    pi.Kind == parentInject,
					IsInterface: pi.InterfaceField,
					IsPointer:   strings.HasPrefix(f.GoType, "*"),
					SourceField: f.SourceFieldName,
				}
			}
			continue
		}

		td.Fields = append(td.Fields, templateField{
			Name:            f.SourceFieldName,
			GoType:          f.GoType,
			JSONName:        f.JSONName,
			SourceJSONNames: f.SourceJSONNames,
		})
	}

	return td
}

var typeTmpl = template.Must(template.New("type").Parse(`
// {{.TypeName}} is a capability model for model.{{.SourceTypeName}}.
type {{.TypeName}} struct {
{{- range .Fields}}
	{{.Name}} {{.GoType}} ` + "`" + `json:"{{.JSONName}}"` + "`" + `
{{- end}}
{{- if .ParentField}}
	{{.ParentField.Name}} {{.ParentField.SlimType}} ` + "`" + `json:"{{.ParentField.JSONName}}"` + "`" + `
{{- end}}
}

// Convert converts this capability model to a full model.{{.SourceTypeName}}.
// It applies defaults and hooks via registry.UnmarshalModel.
func (s {{.TypeName}}) Convert() (*model.{{.SourceTypeName}}, error) {
	m := make(map[string]any)
{{- range $field := .Fields}}
{{- range $field.SourceJSONNames}}
	m["{{.}}"] = s.{{$field.Name}}
{{- end}}
{{- end}}
{{- if .ParentField}}
{{- if or .ParentField.IsInject .ParentField.IsInterface}}
	parentModel, err := s.{{.ParentField.Name}}.Convert()
	if err != nil {
		return nil, err
	}
{{- end}}
{{- end}}

	b, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}

{{- if and .ParentField .ParentField.IsInject}}
	// For types with injected parents, we unmarshal without hooks first,
	// set the parent, then call hooks (which may depend on the parent).
	var result model.{{.SourceTypeName}}
	result.Defaulted()
	if err := json.Unmarshal(b, &result); err != nil {
		return nil, err
	}
	result.{{.ParentField.SourceField}} = model.NewGraphModelWrapper(parentModel)
	if err := registry.CallHooks(&result); err != nil {
		return nil, err
	}
{{- else}}
	var result model.{{.SourceTypeName}}
	if err := registry.UnmarshalModel(b, &result); err != nil {
		return nil, err
	}
{{- if .ParentField}}
{{- if .ParentField.IsInterface}}
	result.{{.ParentField.SourceField}} = parentModel
{{- else if .ParentField.IsPointer}}
	converted, err := s.{{.ParentField.Name}}.Convert()
	if err != nil {
		return nil, err
	}
	result.{{.ParentField.SourceField}} = converted
	if err := registry.CallHooks(&result); err != nil {
		return nil, err
	}
{{- end}}
{{- end}}
{{- end}}

	return &result, nil
}
`))

func writeType(buf *bytes.Buffer, td templateData) error {
	return typeTmpl.Execute(buf, td)
}
