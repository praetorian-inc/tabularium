package model

import (
	"fmt"

	"github.com/praetorian-inc/tabularium/pkg/registry"
)

type ThreatNotificationMetadata struct {
	PraetorianAcknowledged bool `neo4j:"praetorianAcknowledged" json:"praetorianAcknowledged" desc:"Indicates if Praetorian has acknowledged this as an emergent threat." example:"true"`
	PraetorianScanned      bool `neo4j:"praetorianScanned" json:"praetorianScanned" desc:"Indicates if Praetorian is actively scanning for this vulnerability." example:"true"`
	AcknowledgedNotified   bool `neo4j:"acknowledgedNotified" json:"acknowledgedNotified" desc:"Indicates if acknowledgment notification has been sent to customers." example:"false"`
	ScannedNotified        bool `neo4j:"scannedNotified" json:"scannedNotified" desc:"Indicates if scan notification has been sent to customers." example:"false"`
}

// Vulnerability represents the metadata about a vulnerability, in the abstract. This is used to represent
// vulnerability state across all of chariot. This should be used as the basis for the global vulnerability database.
// Vulnerabilities are distinct from Threats. Threats represent metadata about vulnerability from a specific threat feed.
// Vulnerabilities are the single source of truth for vulnerability metadata. Currently, vulnerabilities are all constructed
// from NVD data, but in the future, we will add additional sources, with the appropriate priority. For example,
// we might prioritize our own CVSS scores and descriptions from VKB templates, and then fall back to NVD data.
type Vulnerability struct {
	registry.BaseModel
	Username string `neo4j:"username" json:"username" desc:"Chariot username associated with the vulnerability record (usually global)." example:"global"`
	Key      string `neo4j:"key" json:"key" desc:"Unique key identifying the vulnerability." example:"#vulnerability#CVE-2023-12345"`
	ThreatNotificationMetadata
	Id           string   `neo4j:"id" json:"id" desc:"Identifier for the vulnerability (e.g., CVE ID)." example:"CVE-2023-12345"`
	CVSS         *float32 `neo4j:"cvss,omitempty" json:"cvss,omitempty" desc:"Highest CVSS base score associated with the vulnerability." example:"9.8"`
	EPSS         *float32 `neo4j:"epss,omitempty" json:"epss,omitempty" desc:"EPSS score (probability of exploitation)." example:"0.95"`
	Kev          bool     `neo4j:"kev" json:"kev" desc:"Indicates if the vulnerability is listed in the CISA KEV catalog." example:"true"`
	Feed         *string  `neo4j:"feed,omitempty" json:"feed,omitempty" desc:"Threat feed source (e.g., cisa-kev)." example:"cisa-kev"`
	Data         *string  `neo4j:"data,omitempty" json:"data,omitempty" desc:"Full enrichment data as JSON string." example:"{\"cvss\": 9.8, \"exploits\": [...]}"`
	Exploit      bool     `neo4j:"exploit" json:"exploit" desc:"Indicates if there is known public exploit code available." example:"true"`
	Title        *string  `neo4j:"title" json:"title,omitempty" desc:"Title associated with the vulnerability." example:"Title"`
	WriteupId    *int     `neo4j:"writeupId" json:"writeupId,omitempty" desc:"PlexTrac writeup ID associated with the vulnerability." example:"12345"`
	Created      *string  `neo4j:"created,omitempty" json:"created,omitempty" desc:"Date the vulnerability was first created/published (from NVD)." example:"2023-11-01T00:00:00Z"`
	Updated      *string  `neo4j:"updated,omitempty" json:"updated,omitempty" desc:"Date the vulnerability was last updated (from NVD)." example:"2023-11-10T12:00:00Z"`
	KevDateAdded *string  `neo4j:"kevDateAdded,omitempty" json:"kevDateAdded,omitempty" desc:"Date added to CISA KEV catalog." example:"2024-03-15"`
	KevDueDate   *string  `neo4j:"kevDueDate,omitempty" json:"kevDueDate,omitempty" desc:"CISA KEV remediation due date." example:"2024-04-05"`
}

func init() {
	registry.Registry.MustRegisterModel(&Vulnerability{})
	registry.Registry.MustRegisterModel(&VulnerabilityDefinition{})
}

const VulnerabilityLabel = "Vulnerability"

func (v *Vulnerability) GetLabels() []string {
	return []string{VulnerabilityLabel}
}

func (v *Vulnerability) GetKey() string {
	return v.Key
}

func (v *Vulnerability) Valid() bool {
	return v.Key != ""
}

func (v *Vulnerability) Definition(definition VulnerabilityDefinition) File {
	file := NewFile(fmt.Sprintf("definitions/%s", v.Id))

	body := ""
	if definition.Description != "" {
		body += fmt.Sprintf("<p><strong>Vulnerability Description</strong></p>%s\n", definition.Description)
	}
	if definition.Impact != "" {
		body += fmt.Sprintf("<p><strong>Impact</strong></p>%s\n", definition.Impact)
	}
	if definition.Recommendation != "" {
		body += fmt.Sprintf("<p><strong>Recommendation</strong></p>%s\n", definition.Recommendation)
	}
	if definition.References != "" {
		body += fmt.Sprintf("<p><strong>References</strong></p>%s\n", definition.References)
	}

	file.Bytes = []byte(body)
	return file
}

func (v *Vulnerability) GetHooks() []registry.Hook {
	return []registry.Hook{
		{
			Call: func() error {
				v.Key = fmt.Sprintf("#vulnerability#%s", v.Id)
				return nil
			},
		},
	}
}

func NewVulnerability(id string) Vulnerability {
	v := Vulnerability{
		Id: id,
	}
	v.Defaulted()
	registry.CallHooks(&v)
	return v
}

// GetDescription returns a description for the Vulnerability model.
func (v *Vulnerability) GetDescription() string {
	return "Represents a specific vulnerability identified in the system (e.g., a CVE)."
}

type VulnerabilityDefinition struct {
	registry.BaseModel
	Description    string `json:"description" desc:"Description of the vulnerability." example:"A buffer overflow vulnerability in XYZ software."`
	Impact         string `json:"impact" desc:"Impact of the vulnerability." example:"Remote code execution leading to system compromise."`
	Recommendation string `json:"recommendation" desc:"Recommended actions to mitigate the vulnerability." example:"Apply the latest security patch."`
	References     string `json:"references" desc:"References of the vulnerability." example:"https://nvd.nist.gov/vuln/detail/CVE-2023-12345"`
}

func (vd *VulnerabilityDefinition) GetDescription() string {
	return "Represents the detailed definition of a vulnerability, including its description, impact, and recommendations."
}

func (v *Vulnerability) Merge(update Vulnerability) {
	if update.PraetorianAcknowledged {
		v.PraetorianAcknowledged = true
	}
	if update.PraetorianScanned {
		v.PraetorianScanned = true
	}
	if update.AcknowledgedNotified {
		v.AcknowledgedNotified = true
	}
	if update.ScannedNotified {
		v.ScannedNotified = true
	}

	if update.CVSS != nil {
		v.CVSS = update.CVSS
	}
	if update.EPSS != nil {
		v.EPSS = update.EPSS
	}
	if update.Kev {
		v.Kev = true
	}
	if update.Exploit {
		v.Exploit = true
	}
	if update.Feed != nil {
		v.Feed = update.Feed
	}
	if update.Data != nil {
		v.Data = update.Data
	}
	if update.Title != nil {
		v.Title = update.Title
	}
	if update.WriteupId != nil {
		v.WriteupId = update.WriteupId
	}
	if update.Created != nil {
		v.Created = update.Created
	}
	if update.Updated != nil {
		v.Updated = update.Updated
	}
	if update.KevDateAdded != nil {
		v.KevDateAdded = update.KevDateAdded
	}
	if update.KevDueDate != nil {
		v.KevDueDate = update.KevDueDate
	}
}
