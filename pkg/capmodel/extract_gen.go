// Code generated by capmodelgen; DO NOT EDIT.

package capmodel

import (
	"fmt"

	"github.com/praetorian-inc/tabularium/pkg/capmodel/internal/models"
	"github.com/praetorian-inc/tabularium/pkg/model/model"
	"github.com/praetorian-inc/tabularium/pkg/registry"
)

func init() {
	registry.Registry.MustRegisterExtractor("ADObject", extractADObject)
	registry.Registry.MustRegisterExtractor("AWSResource", extractAWSResource)
	registry.Registry.MustRegisterExtractor("Asset", extractAsset)
	registry.Registry.MustRegisterExtractor("AzureResource", extractAzureResource)
	registry.Registry.MustRegisterExtractor("Domain", extractDomain)
	registry.Registry.MustRegisterExtractor("File", extractFile)
	registry.Registry.MustRegisterExtractor("GCPResource", extractGCPResource)
	registry.Registry.MustRegisterExtractor("IP", extractIP)
	registry.Registry.MustRegisterExtractor("Organization", extractOrganization)
	registry.Registry.MustRegisterExtractor("Person", extractPerson)
	registry.Registry.MustRegisterExtractor("Port", extractPort)
	registry.Registry.MustRegisterExtractor("Preseed", extractPreseed)
	registry.Registry.MustRegisterExtractor("Risk", extractRisk)
	registry.Registry.MustRegisterExtractor("Technology", extractTechnology)
	registry.Registry.MustRegisterExtractor("WebApplication", extractWebApplication)
	registry.Registry.MustRegisterExtractor("Webpage", extractWebpage)
}

func extractADObject(m registry.Model) (any, error) {
	src, ok := m.(*model.ADObject)
	if !ok {
		return nil, fmt.Errorf("extractADObject: expected *model.ADObject, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.ADObject{
		Label:                                   src.Label,
		SecondaryLabels:                         src.SecondaryLabels,
		Domain:                                  src.Domain,
		ObjectID:                                src.ObjectID,
		SID:                                     src.SID,
		Name:                                    src.Name,
		Description:                             src.Description,
		DisplayName:                             src.DisplayName,
		IsDeleted:                               src.IsDeleted,
		AdminCount:                              src.AdminCount,
		CASecurityCollected:                     src.CASecurityCollected,
		CAName:                                  src.CAName,
		CertChain:                               src.CertChain,
		CertName:                                src.CertName,
		CertThumbprint:                          src.CertThumbprint,
		CertThumbprints:                         src.CertThumbprints,
		HasEnrollmentAgentRestrictions:          src.HasEnrollmentAgentRestrictions,
		EnrollmentAgentRestrictionsCollected:    src.EnrollmentAgentRestrictionsCollected,
		IsUserSpecifiesSanEnabled:               src.IsUserSpecifiesSanEnabled,
		IsUserSpecifiesSanEnabledCollected:      src.IsUserSpecifiesSanEnabledCollected,
		RoleSeparationEnabled:                   src.RoleSeparationEnabled,
		RoleSeparationEnabledCollected:          src.RoleSeparationEnabledCollected,
		HasBasicConstraints:                     src.HasBasicConstraints,
		BasicConstraintPathLength:               src.BasicConstraintPathLength,
		UnresolvedPublishedTemplates:            src.UnresolvedPublishedTemplates,
		DNSHostname:                             src.DNSHostname,
		CrossCertificatePair:                    src.CrossCertificatePair,
		DistinguishedName:                       src.DistinguishedName,
		DomainSID:                               src.DomainSID,
		Sensitive:                               src.Sensitive,
		BlocksInheritance:                       src.BlocksInheritance,
		IsACL:                                   src.IsACL,
		IsACLProtected:                          src.IsACLProtected,
		InheritanceHash:                         src.InheritanceHash,
		InheritanceHashes:                       src.InheritanceHashes,
		Enforced:                                src.Enforced,
		Department:                              src.Department,
		HasCrossCertificatePair:                 src.HasCrossCertificatePair,
		HasSPN:                                  src.HasSPN,
		UnconstrainedDelegation:                 src.UnconstrainedDelegation,
		LastLogon:                               src.LastLogon,
		LastLogonTimestamp:                      src.LastLogonTimestamp,
		IsPrimaryGroup:                          src.IsPrimaryGroup,
		HasLAPS:                                 src.HasLAPS,
		DontRequirePreAuth:                      src.DontRequirePreAuth,
		LogonType:                               src.LogonType,
		HasURA:                                  src.HasURA,
		PasswordNeverExpires:                    src.PasswordNeverExpires,
		PasswordNotRequired:                     src.PasswordNotRequired,
		FunctionalLevel:                         src.FunctionalLevel,
		TrustType:                               src.TrustType,
		SpoofSIDHistoryBlocked:                  src.SpoofSIDHistoryBlocked,
		TrustedToAuth:                           src.TrustedToAuth,
		SAMAccountName:                          src.SAMAccountName,
		CertificateMappingMethodsRaw:            src.CertificateMappingMethodsRaw,
		CertificateMappingMethods:               src.CertificateMappingMethods,
		StrongCertificateBindingEnforcementRaw:  src.StrongCertificateBindingEnforcementRaw,
		StrongCertificateBindingEnforcement:     src.StrongCertificateBindingEnforcement,
		EKUs:                                    src.EKUs,
		SubjectAltRequireUPN:                    src.SubjectAltRequireUPN,
		SubjectAltRequireDNS:                    src.SubjectAltRequireDNS,
		SubjectAltRequireDomainDNS:              src.SubjectAltRequireDomainDNS,
		SubjectAltRequireEmail:                  src.SubjectAltRequireEmail,
		SubjectAltRequireSPN:                    src.SubjectAltRequireSPN,
		SubjectRequireEmail:                     src.SubjectRequireEmail,
		AuthorizedSignatures:                    src.AuthorizedSignatures,
		ApplicationPolicies:                     src.ApplicationPolicies,
		IssuancePolicies:                        src.IssuancePolicies,
		SchemaVersion:                           src.SchemaVersion,
		RequiresManagerApproval:                 src.RequiresManagerApproval,
		AuthenticationEnabled:                   src.AuthenticationEnabled,
		SchannelAuthenticationEnabled:           src.SchannelAuthenticationEnabled,
		EnrolleeSuppliesSubject:                 src.EnrolleeSuppliesSubject,
		CertificateApplicationPolicy:            src.CertificateApplicationPolicy,
		CertificateNameFlag:                     src.CertificateNameFlag,
		EffectiveEKUs:                           src.EffectiveEKUs,
		EnrollmentFlag:                          src.EnrollmentFlag,
		Flags:                                   src.Flags,
		NoSecurityExtension:                     src.NoSecurityExtension,
		RenewalPeriod:                           src.RenewalPeriod,
		ValidityPeriod:                          src.ValidityPeriod,
		OID:                                     src.OID,
		HomeDirectory:                           src.HomeDirectory,
		CertificatePolicy:                       src.CertificatePolicy,
		CertTemplateOID:                         src.CertTemplateOID,
		GroupLinkID:                             src.GroupLinkID,
		ObjectGUID:                              src.ObjectGUID,
		ExpirePasswordsOnSmartCardOnlyAccounts:  src.ExpirePasswordsOnSmartCardOnlyAccounts,
		MachineAccountQuota:                     src.MachineAccountQuota,
		SupportedKerberosEncryptionTypes:        src.SupportedKerberosEncryptionTypes,
		TGTDelegation:                           src.TGTDelegation,
		PasswordStoredUsingReversibleEncryption: src.PasswordStoredUsingReversibleEncryption,
		SmartcardRequired:                       src.SmartcardRequired,
		UseDESKeyOnly:                           src.UseDESKeyOnly,
		LogonScriptEnabled:                      src.LogonScriptEnabled,
		LockedOut:                               src.LockedOut,
		UserCannotChangePassword:                src.UserCannotChangePassword,
		PasswordExpired:                         src.PasswordExpired,
		DSHeuristics:                            src.DSHeuristics,
		UserAccountControl:                      src.UserAccountControl,
		TrustAttributesInbound:                  src.TrustAttributesInbound,
		TrustAttributesOutbound:                 src.TrustAttributesOutbound,
		MinPwdLength:                            src.MinPwdLength,
		PwdProperties:                           src.PwdProperties,
		PwdHistoryLength:                        src.PwdHistoryLength,
		LockoutThreshold:                        src.LockoutThreshold,
		MinPwdAge:                               src.MinPwdAge,
		MaxPwdAge:                               src.MaxPwdAge,
		LockoutDuration:                         src.LockoutDuration,
		LockoutObservationWindow:                src.LockoutObservationWindow,
		OwnerSid:                                src.OwnerSid,
		SMBSigning:                              src.SMBSigning,
		WebClientRunning:                        src.WebClientRunning,
		RestrictOutboundNTLM:                    src.RestrictOutboundNTLM,
		GMSA:                                    src.GMSA,
		MSA:                                     src.MSA,
		DoesAnyAceGrantOwnerRights:              src.DoesAnyAceGrantOwnerRights,
		DoesAnyInheritedAceGrantOwnerRights:     src.DoesAnyInheritedAceGrantOwnerRights,
		ADCSWebEnrollmentHTTP:                   src.ADCSWebEnrollmentHTTP,
		ADCSWebEnrollmentHTTPS:                  src.ADCSWebEnrollmentHTTPS,
		ADCSWebEnrollmentHTTPSEPA:               src.ADCSWebEnrollmentHTTPSEPA,
		LDAPSigning:                             src.LDAPSigning,
		LDAPAvailable:                           src.LDAPAvailable,
		LDAPSAvailable:                          src.LDAPSAvailable,
		LDAPSEPA:                                src.LDAPSEPA,
		IsDC:                                    src.IsDC,
		IsReadOnlyDC:                            src.IsReadOnlyDC,
		HTTPEnrollmentEndpoints:                 src.HTTPEnrollmentEndpoints,
		HTTPSEnrollmentEndpoints:                src.HTTPSEnrollmentEndpoints,
		HasVulnerableEndpoint:                   src.HasVulnerableEndpoint,
		RequireSecuritySignature:                src.RequireSecuritySignature,
		EnableSecuritySignature:                 src.EnableSecuritySignature,
		RestrictReceivingNTLMTraffic:            src.RestrictReceivingNTLMTraffic,
		NTLMMinServerSec:                        src.NTLMMinServerSec,
		NTLMMinClientSec:                        src.NTLMMinClientSec,
		LMCompatibilityLevel:                    src.LMCompatibilityLevel,
		UseMachineID:                            src.UseMachineID,
		ClientAllowedNTLMServers:                src.ClientAllowedNTLMServers,
		Transitive:                              src.Transitive,
		GroupScope:                              src.GroupScope,
		NetBIOS:                                 src.NetBIOS,
		AdminSDHolderProtected:                  src.AdminSDHolderProtected,
		ServicePrincipalNames:                   src.ServicePrincipalNames,
		OperatingSystem:                         src.OperatingSystem,
	}
	return &result, nil
}

func extractAWSResource(m registry.Model) (any, error) {
	src, ok := m.(*model.AWSResource)
	if !ok {
		return nil, fmt.Errorf("extractAWSResource: expected *model.AWSResource, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.AWSResource{
		IPs:          src.IPs,
		URLs:         src.URLs,
		Name:         src.Name,
		ResourceType: string(src.ResourceType),
		Region:       src.Region,
		AccountRef:   src.AccountRef,
		Properties:   src.Properties,
	}
	return &result, nil
}

func extractAsset(m registry.Model) (any, error) {
	src, ok := m.(*model.Asset)
	if !ok {
		return nil, fmt.Errorf("extractAsset: expected *model.Asset, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Asset{
		DNS:  src.DNS,
		Name: src.Name,
	}
	return &result, nil
}

func extractAzureResource(m registry.Model) (any, error) {
	src, ok := m.(*model.AzureResource)
	if !ok {
		return nil, fmt.Errorf("extractAzureResource: expected *model.AzureResource, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.AzureResource{
		IPs:           src.IPs,
		URLs:          src.URLs,
		Name:          src.Name,
		ResourceType:  string(src.ResourceType),
		Region:        src.Region,
		AccountRef:    src.AccountRef,
		Properties:    src.Properties,
		ResourceGroup: src.ResourceGroup,
	}
	return &result, nil
}

func extractDomain(m registry.Model) (any, error) {
	src, ok := m.(*model.Asset)
	if !ok {
		return nil, fmt.Errorf("extractDomain: expected *model.Asset, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Domain{
		Domain: src.DNS,
	}
	return &result, nil
}

func extractFile(m registry.Model) (any, error) {
	src, ok := m.(*model.File)
	if !ok {
		return nil, fmt.Errorf("extractFile: expected *model.File, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.File{
		Name:  src.Name,
		Bytes: []byte(src.Bytes),
	}
	return &result, nil
}

func extractGCPResource(m registry.Model) (any, error) {
	src, ok := m.(*model.GCPResource)
	if !ok {
		return nil, fmt.Errorf("extractGCPResource: expected *model.GCPResource, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.GCPResource{
		IPs:          src.IPs,
		URLs:         src.URLs,
		Name:         src.Name,
		ResourceType: string(src.ResourceType),
		Region:       src.Region,
		AccountRef:   src.AccountRef,
		Properties:   src.Properties,
	}
	return &result, nil
}

func extractIP(m registry.Model) (any, error) {
	src, ok := m.(*model.Asset)
	if !ok {
		return nil, fmt.Errorf("extractIP: expected *model.Asset, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.IP{
		IP: src.DNS,
	}
	return &result, nil
}

func extractOrganization(m registry.Model) (any, error) {
	src, ok := m.(*model.Organization)
	if !ok {
		return nil, fmt.Errorf("extractOrganization: expected *model.Organization, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Organization{
		Name:                  src.Name,
		Domain:                src.Domain,
		Website:               src.Website,
		Description:           src.Description,
		Industry:              src.Industry,
		SubIndustries:         src.SubIndustries,
		Keywords:              src.Keywords,
		OrganizationType:      src.OrganizationType,
		BusinessModel:         src.BusinessModel,
		EstimatedNumEmployees: src.EstimatedNumEmployees,
		EmployeeRange:         src.EmployeeRange,
		AnnualRevenue:         src.AnnualRevenue,
		RevenueRange:          src.RevenueRange,
		MarketCapitalization:  src.MarketCapitalization,
		Country:               src.Country,
		State:                 src.State,
		City:                  src.City,
		PostalCode:            src.PostalCode,
		StreetAddress:         src.StreetAddress,
		Phone:                 src.Phone,
		Fax:                   src.Fax,
		Email:                 src.Email,
		LinkedinURL:           src.LinkedinURL,
		TwitterURL:            src.TwitterURL,
		FacebookURL:           src.FacebookURL,
		BlogURL:               src.BlogURL,
		FoundedYear:           src.FoundedYear,
		PubliclyTraded:        src.PubliclyTraded,
		TickerSymbol:          src.TickerSymbol,
		Exchange:              src.Exchange,
		Technologies:          src.Technologies,
		TechCategories:        src.TechCategories,
		TechVendors:           src.TechVendors,
		AlternatePhones:       src.AlternatePhones,
		PhoneTypes:            src.PhoneTypes,
		FundingRounds:         src.FundingRounds,
		FundingAmounts:        src.FundingAmounts,
		Investors:             src.Investors,
		AdditionalAddresses:   src.AdditionalAddresses,
		AddressTypes:          src.AddressTypes,
	}
	return &result, nil
}

func extractPerson(m registry.Model) (any, error) {
	src, ok := m.(*model.Person)
	if !ok {
		return nil, fmt.Errorf("extractPerson: expected *model.Person, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Person{
		FirstName:        src.FirstName,
		LastName:         src.LastName,
		Name:             src.Name,
		Email:            src.Email,
		Title:            src.Title,
		Headline:         src.Headline,
		Phone:            src.Phone,
		PersonalEmails:   src.PersonalEmails,
		WorkEmail:        src.WorkEmail,
		LinkedinURL:      src.LinkedinURL,
		TwitterURL:       src.TwitterURL,
		FacebookURL:      src.FacebookURL,
		GithubURL:        src.GithubURL,
		PhotoURL:         src.PhotoURL,
		OrganizationName: src.OrganizationName,
		Country:          src.Country,
		State:            src.State,
		City:             src.City,
		Seniority:        src.Seniority,
		Departments:      src.Departments,
		Functions:        src.Functions,
	}
	return &result, nil
}

func extractPort(m registry.Model) (any, error) {
	src, ok := m.(*model.Port)
	if !ok {
		return nil, fmt.Errorf("extractPort: expected *model.Port, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Port{
		Protocol: src.Protocol,
		Port:     src.Port,
		Service:  src.Service,
	}
	if src.Parent.Model != nil {
		p, err := registry.Registry.Extract("Asset", src.Parent.Model)
		if err != nil {
			return nil, err
		}
		typed, ok := p.(*models.Asset)
		if !ok {
			return nil, fmt.Errorf("extractPort: parent is %T, not *models.Asset", p)
		}
		result.Parent = *typed
	}
	return &result, nil
}

func extractPreseed(m registry.Model) (any, error) {
	src, ok := m.(*model.Preseed)
	if !ok {
		return nil, fmt.Errorf("extractPreseed: expected *model.Preseed, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Preseed{
		Type:  src.Type,
		Title: src.Title,
		Value: src.Value,
	}
	return &result, nil
}

func extractRisk(m registry.Model) (any, error) {
	src, ok := m.(*model.Risk)
	if !ok {
		return nil, fmt.Errorf("extractRisk: expected *model.Risk, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Risk{
		DNS:    src.DNS,
		Name:   src.Name,
		Source: src.Source,
		Status: src.Status,
	}
	if src.Target != nil {
		p, err := registry.Registry.Extract("Asset", src.Target)
		if err != nil {
			return nil, err
		}
		typed, ok := p.(*models.Asset)
		if !ok {
			return nil, fmt.Errorf("extractRisk: parent is %T, not *models.Asset", p)
		}
		result.Target = *typed
	}
	return &result, nil
}

func extractTechnology(m registry.Model) (any, error) {
	src, ok := m.(*model.Technology)
	if !ok {
		return nil, fmt.Errorf("extractTechnology: expected *model.Technology, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Technology{
		CPE:  src.CPE,
		Name: src.Name,
	}
	return &result, nil
}

func extractWebApplication(m registry.Model) (any, error) {
	src, ok := m.(*model.WebApplication)
	if !ok {
		return nil, fmt.Errorf("extractWebApplication: expected *model.WebApplication, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.WebApplication{
		PrimaryURL: src.PrimaryURL,
		URLs:       src.URLs,
		Name:       src.Name,
	}
	return &result, nil
}

func extractWebpage(m registry.Model) (any, error) {
	src, ok := m.(*model.Webpage)
	if !ok {
		return nil, fmt.Errorf("extractWebpage: expected *model.Webpage, got %T", m)
	}
	if e, ok := m.(registry.Extractable); ok {
		e.PrepareForExtract()
	}
	result := models.Webpage{
		URL: src.URL,
	}
	if src.Parent != nil {
		p, err := registry.Registry.Extract("WebApplication", src.Parent)
		if err != nil {
			return nil, err
		}
		typed, ok := p.(*models.WebApplication)
		if !ok {
			return nil, fmt.Errorf("extractWebpage: parent is %T, not *models.WebApplication", p)
		}
		result.Parent = *typed
	}
	return &result, nil
}
